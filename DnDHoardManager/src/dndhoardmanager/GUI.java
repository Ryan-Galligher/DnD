/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package dndhoardmanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Scanner;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import dndminions.*;
import javax.swing.JFrame;
//import java.awt.Component;



/**
 *
 * @author Ryan
 */
public class GUI extends javax.swing.JFrame {

    
    ArrayList<Minions> list = new ArrayList<>();
    ArrayList<String> attackNotes = new ArrayList<>();
    ArrayList<Integer> numRepeatingAttackNotes = new ArrayList<>();
    File importedFile;
    final File defaultFile = new File("MinionListUpdatedMaybe2.csv");
    
    int highlitedRow=0;
    int wizlv;
    int proficiency; 
    private final boolean dynamicallyFindClass=true;
    int spotColumn=0;
    
    int attackListSpotColumn=spotColumn;
    int attackListDamageColumn=3;
    int attackListHitConfirmColumn=4;
    
    int minionListSpot=spotColumn;
    int minionListName=1;
    int minionListHP=2;
    int minionListAC=3;
    int minionListAttackingMonster=4;
   
    int monsterListDamageDelt=0;    //IS NOT COMPLETELY FINISHED YET NEED TO FIX PROPERLY#######################
    
    
    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        WizlvSlider = new javax.swing.JSlider();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        ProficiencySlider = new javax.swing.JSlider();
        jPanel6 = new javax.swing.JPanel();
        AddButton = new javax.swing.JButton();
        DeleteButton = new javax.swing.JButton();
        ExportButton = new javax.swing.JButton();
        ImportButton = new javax.swing.JButton();
        RollButton = new javax.swing.JButton();
        ReloadButton = new javax.swing.JButton();
        SumButton = new javax.swing.JButton();
        ClearAllButton = new javax.swing.JButton();
        ClearRoundButton = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        MinionList = new javax.swing.JTable();
        jPanel4 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        AttackList = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        MonsterList = new javax.swing.JTable();
        jLabel5 = new javax.swing.JLabel();
        jPanel7 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        MinionNumberDamageField = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        DamageDealtToMinionTextField = new javax.swing.JTextField();
        DamageButton = new javax.swing.JButton();
        jLabel10 = new javax.swing.JLabel();
        KillMonsterText = new javax.swing.JTextField();
        KillMonsterButton = new javax.swing.JButton();
        jLabel6 = new javax.swing.JLabel();
        MinionNumberField = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        MonsterNumberField = new javax.swing.JTextField();
        SetButton = new javax.swing.JButton();
        jPanel8 = new javax.swing.JPanel();
        jLabel11 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        MinionDescriptionField = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Wizard Level");

        WizlvSlider.setMajorTickSpacing(1);
        WizlvSlider.setMaximum(20);
        WizlvSlider.setMinimum(1);
        WizlvSlider.setPaintLabels(true);
        WizlvSlider.setPaintTicks(true);
        WizlvSlider.setSnapToTicks(true);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(WizlvSlider, javax.swing.GroupLayout.PREFERRED_SIZE, 304, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(WizlvSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(20, 20, 20))
        );

        jLabel2.setText("Proficiency");

        ProficiencySlider.setMajorTickSpacing(1);
        ProficiencySlider.setMaximum(6);
        ProficiencySlider.setMinimum(1);
        ProficiencySlider.setPaintLabels(true);
        ProficiencySlider.setPaintTicks(true);
        ProficiencySlider.setSnapToTicks(true);

        AddButton.setText("Add Row");

        DeleteButton.setText("Delete Row");

        ExportButton.setText("Export Data");
        ExportButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExportButtonActionPerformed(evt);
            }
        });

        ImportButton.setText("Import Data");
        ImportButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ImportButtonActionPerformed(evt);
            }
        });

        RollButton.setText("Roll Attack");
        RollButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RollButtonActionPerformed(evt);
            }
        });

        ReloadButton.setText("Reload");
        ReloadButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReloadButtonActionPerformed(evt);
            }
        });

        SumButton.setText("Sum Damage");
        SumButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SumButtonActionPerformed(evt);
            }
        });

        ClearAllButton.setText("Clear All");
        ClearAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearAllButtonActionPerformed(evt);
            }
        });

        ClearRoundButton.setText("Clear Round");
        ClearRoundButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearRoundButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(ImportButton, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(ExportButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(ReloadButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(AddButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(DeleteButton, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE)
                    .addComponent(ClearAllButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(10, 10, 10)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(SumButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(ClearRoundButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(RollButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ImportButton)
                    .addComponent(AddButton)
                    .addComponent(RollButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ExportButton)
                    .addComponent(DeleteButton)
                    .addComponent(SumButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ReloadButton, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ClearAllButton)
                    .addComponent(ClearRoundButton))
                .addGap(11, 11, 11))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ProficiencySlider, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ProficiencySlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        MinionList.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null}
            },
            new String [] {
                "Number", "Name", "HP", "AC", "Attacking"
            }
        ));
        MinionList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                MinionListMouseClicked(evt);
            }
        });
        MinionList.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                MinionListKeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(MinionList);

        AttackList.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null},
                {null, null, null, null, null}
            },
            new String [] {
                "Minion #", "Name", "Attack Roll", "Damage", "Hit?"
            }
        ));
        jScrollPane2.setViewportView(AttackList);

        jLabel4.setText("Attack Results");

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addContainerGap(229, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 438, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jLabel3.setText("Minion List");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(19, 19, 19)
                        .addComponent(jLabel3))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 390, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 35, Short.MAX_VALUE)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 438, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        MonsterList.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Number", "Name", "AC?", "Hurt"
            }
        ));
        jScrollPane3.setViewportView(MonsterList);

        jLabel5.setText("Monsters");

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel5)
                .addGap(7, 7, 7)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel8.setText("Minion #");

        MinionNumberDamageField.setText("1");

        jLabel9.setText("Damage Dealt to Minion");

        DamageDealtToMinionTextField.setText("0");

        DamageButton.setText("Deal Damage");
        DamageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DamageButtonActionPerformed(evt);
            }
        });

        jLabel10.setText("Kill Monster #");

        KillMonsterText.setText("1");

        KillMonsterButton.setText("Kill Monster");
        KillMonsterButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                KillMonsterButtonActionPerformed(evt);
            }
        });

        jLabel6.setText("Minion #");

        MinionNumberField.setText("1");

        jLabel7.setText("Monster #");

        MonsterNumberField.setText("1");

        SetButton.setText("Set Attack");
        SetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SetButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jLabel8))
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(MinionNumberDamageField, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel9)
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(DamageDealtToMinionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(DamageButton)))
                .addGap(27, 27, 27)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel10)
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(KillMonsterText, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(KillMonsterButton)))
                .addGap(25, 25, 25)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(MinionNumberField)
                    .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(MonsterNumberField))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(SetButton)
                .addGap(293, 293, 293))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel8)
                    .addComponent(jLabel9)
                    .addComponent(jLabel10)
                    .addComponent(jLabel6)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(MinionNumberDamageField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(DamageDealtToMinionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(DamageButton)
                    .addComponent(KillMonsterText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(KillMonsterButton)
                    .addComponent(MinionNumberField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(MonsterNumberField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(SetButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel11.setText("Attacks Minion Can Do");

        MinionDescriptionField.setColumns(20);
        MinionDescriptionField.setRows(5);
        MinionDescriptionField.setText("No Minion Selected.\n");
        jScrollPane4.setViewportView(MinionDescriptionField);

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel11, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addComponent(jLabel11)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 144, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jPanel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 891, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(9, 9, 9)
                        .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 472, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(3, 3, 3))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void SetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SetButtonActionPerformed
        // TODO add your handling code here:
        System.out.println("Attempting to set who the minion is attacking");
        try{
            int minionSpot = Integer.parseInt(MinionNumberField.getText())-1;
            if(!MinionList.getModel().getValueAt(minionSpot, minionListSpot).equals(""))
            {
                int monsterSpot = Integer.parseInt(MonsterNumberField.getText()) ;
                MinionList.getModel().setValueAt("" + monsterSpot, minionSpot, minionListAttackingMonster);  //Stores the spot of the monster they are attacking, using the row of the minion and the column that stores what monster a minion is attacking
                MinionNumberField.setText("");
            }
            else
                JOptionPane.showMessageDialog(this, "ERROR: Selected Minion Does Not Exist");
            
        }catch(Exception e){JOptionPane.showMessageDialog(this, e);}
    }//GEN-LAST:event_SetButtonActionPerformed

    private void DamageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DamageButtonActionPerformed
        // TODO add your handling code here:
        try{
            System.out.println("Starting to deal some damage to a creature");
            int minionSpot = Integer.parseInt(MinionNumberDamageField.getText())-1;
            if(!MinionList.getModel().getValueAt(minionSpot, minionListSpot).equals(""))
            {
                int damageAmount = Integer.parseInt(DamageDealtToMinionTextField.getText());
                System.out.println("Got both a minionSpot as " + minionSpot + " and damageAmount as " + damageAmount);
                dealDamage(damageAmount, minionSpot, minionListHP);
                MinionNumberDamageField.setText("");
            }
            else
                JOptionPane.showMessageDialog(this, "ERROR: Selected Minion Does Not Exist");
            
        }catch(Exception e){JOptionPane.showMessageDialog(this, e);e.printStackTrace();}
    }//GEN-LAST:event_DamageButtonActionPerformed

    private void KillMonsterButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_KillMonsterButtonActionPerformed
        // TODO add your handling code here:
        try{
            int monsterSpot = Integer.parseInt(KillMonsterText.getText())-1;
            deleteRow(monsterSpot, MonsterList, true);  //Deletes the Monster and the row that it is in
            
            try{
            for(int i = 0; i < MinionList.getModel().getRowCount(); i++)    //Goes through every minion, and then changes them so that they are attacking a real/the correct monster
            {
                int minionIsAttackingValue;
                boolean stringOrInt;    //If it is a String, put true. If it is an int, put false.
                
                try{
                    minionIsAttackingValue = Integer.parseInt((String)MinionList.getModel().getValueAt(i, minionListAttackingMonster))-1;
                    stringOrInt=true;
                }catch(ClassCastException e){
                    minionIsAttackingValue = (Integer)MinionList.getModel().getValueAt(i,minionListAttackingMonster);
                    stringOrInt=false;
                }
                
                int changeToAttacking=minionIsAttackingValue;   //If the minion was attacking a monster at a spot smaller that was just killed, keep that minion fighting assigned monster
                
                if(minionIsAttackingValue==monsterSpot) //If the minion was attacking the monster that just died, asks who the minion should attack now
                {
                    changeToAttacking=Integer.parseInt( JOptionPane.showInputDialog("What is the spot of the Monster that " + list.get(i).getName() + " at spot " + ((i+1)) + " should attack now?"))-1;  //Asks the user who the minion should attack now if the monster has been changed. Subtracts 1 so that it deals with Arrays Starting at 0.
                    if(changeToAttacking<=0)
                    {
                        JOptionPane.showMessageDialog(this, "ERROR: Selected Monster Does Not Exist. Assuming that Minion wants to attack Monster at spot 1");
                        changeToAttacking=1;
                    }
                }
                if(minionIsAttackingValue>monsterSpot)  //If the minion was attacking a monster with a higher spot that that that just died, then reduce the spot that the creature is attacking by 1 so it is still attacking the correct monster
                    changeToAttacking=minionIsAttackingValue-1;
                    
                if(stringOrInt) //If it reads from the table as a String, input it back as a String. If it reads it as an int, input it back as an int.
                    MinionList.getModel().setValueAt("" + (changeToAttacking+1), i, minionListAttackingMonster);
                else
                    MinionList.getModel().setValueAt(changeToAttacking+1, i, minionListAttackingMonster);
            }
            }catch(NumberFormatException e){}   //If the code goes far enough down in the AttackMinion table so that it reaches values that are simply "", then it terminates the for loop
        }catch(Exception e){JOptionPane.showMessageDialog(this, e);e.printStackTrace();}
    }//GEN-LAST:event_KillMonsterButtonActionPerformed

    private void MinionListMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_MinionListMouseClicked
        // TODO add your handling code here:
        //Will Switch Description to the Minion at the row, or skip if same row as currently is.
        changeShownRow();

    }//GEN-LAST:event_MinionListMouseClicked

    private void MinionListKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_MinionListKeyReleased
        // TODO add your handling code here:
        //Should same thing as Mouse Clicked
        changeShownRow();
    }//GEN-LAST:event_MinionListKeyReleased

    private void ClearRoundButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearRoundButtonActionPerformed
        // TODO add your handling code here:
        clearAttackRound();
    }//GEN-LAST:event_ClearRoundButtonActionPerformed

    private void ClearAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearAllButtonActionPerformed
        // TODO add your handling code here:
        if(JOptionPane.showConfirmDialog(new JFrame(),
            "Are you sure you want to clear everything?",
            "Exitting Window", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION)
    clearAll();
    }//GEN-LAST:event_ClearAllButtonActionPerformed

    private void SumButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SumButtonActionPerformed
        // TODO add your handling code here:
        System.out.println("");
        System.out.println("Starting to Sum up all of the damage");
        for(int i = 0; i < AttackList.getModel().getRowCount();i++) //For every attack that has been executed
        {
            System.out.println("    Currently viewing the " + i + " attack");
            if(attackLanded((String)AttackList.getModel().getValueAt(i, attackListHitConfirmColumn)))   //If the user has manually gone in and confirmed that the attack hit
            {
                System.out.println("    Attack " + i + " did hit");
                String stuff = (String)AttackList.getModel().getValueAt(i, attackListSpotColumn);   //Get the String of the minion that the attack origionated from
                System.out.println("        {" + stuff + "}");
                int attackCameFromThisMinion = Integer.parseInt(stuff); //convert it to int
                System.out.println("        attackCameFromThisMinion was able to successfully get the value");
                int monsterSpot = Integer.parseInt( (String)MinionList.getModel().getValueAt(attackCameFromThisMinion-1, minionListAttackingMonster) )-1;    //Gets Monster That specific Attack is Attacking
                System.out.println("        monsterSpot was able to successfully get the value");
                if(MonsterList.getModel().getValueAt(monsterSpot,attackListDamageColumn).equals(""))
                MonsterList.getModel().setValueAt(AttackList.getModel().getValueAt(i, attackListDamageColumn),monsterSpot,attackListDamageColumn);
                else
                MonsterList.getModel().setValueAt("" + (Integer.parseInt((String)AttackList.getModel().getValueAt(i, attackListDamageColumn)) + Integer.parseInt((String)MonsterList.getModel().getValueAt(monsterSpot,attackListDamageColumn))),monsterSpot,attackListDamageColumn);
            }
        }
    }//GEN-LAST:event_SumButtonActionPerformed

    private void ReloadButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReloadButtonActionPerformed
        // TODO add your handling code here:
        updateLvAndProficiency();
        clearNonMonster();
        try{
            importDataCSV(importedFile);
        }catch(Exception e){JOptionPane.showMessageDialog(this, e);e.printStackTrace();}
    }//GEN-LAST:event_ReloadButtonActionPerformed

    private void RollButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RollButtonActionPerformed
        // TODO add your handling code here:
        clearDamageDealtMonsters();
        rollAttack();
    }//GEN-LAST:event_RollButtonActionPerformed

    private void ImportButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ImportButtonActionPerformed
        // TODO add your handling code here:
        clearAll();
        updateLvAndProficiency();
        System.out.println("Gotten into choosing the file from the computer");
        //Have data read from excel spreadsheet and put it into program
        try{
            if(JOptionPane.showConfirmDialog(new JFrame(),
                "Do you want to Use the Default Path?",
                "Exitting Window", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION)
        {
            JFileChooser jfc = new JFileChooser();
            if (jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
            {
                importDataCSV(jfc.getSelectedFile());
                importedFile=jfc.getSelectedFile();
                System.out.println("Finished Importing Data and Saving -> " + importedFile);
            }
        }
        else
        {
            importDataCSV(defaultFile);
            importedFile=defaultFile;
            System.out.println("Finished Importing Data and Saving -> " + importedFile);
        }
        } catch(Exception ex) {JOptionPane.showMessageDialog(this, ex);}
    }//GEN-LAST:event_ImportButtonActionPerformed

    private void ExportButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExportButtonActionPerformed
        // TODO add your handling code here:
        exportDataCSV();
    }//GEN-LAST:event_ExportButtonActionPerformed

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
            
        });
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AddButton;
    private javax.swing.JTable AttackList;
    private javax.swing.JButton ClearAllButton;
    private javax.swing.JButton ClearRoundButton;
    private javax.swing.JButton DamageButton;
    private javax.swing.JTextField DamageDealtToMinionTextField;
    private javax.swing.JButton DeleteButton;
    private javax.swing.JButton ExportButton;
    private javax.swing.JButton ImportButton;
    private javax.swing.JButton KillMonsterButton;
    private javax.swing.JTextField KillMonsterText;
    private javax.swing.JTextArea MinionDescriptionField;
    private javax.swing.JTable MinionList;
    private javax.swing.JTextField MinionNumberDamageField;
    private javax.swing.JTextField MinionNumberField;
    private javax.swing.JTable MonsterList;
    private javax.swing.JTextField MonsterNumberField;
    private javax.swing.JSlider ProficiencySlider;
    private javax.swing.JButton ReloadButton;
    private javax.swing.JButton RollButton;
    private javax.swing.JButton SetButton;
    private javax.swing.JButton SumButton;
    private javax.swing.JSlider WizlvSlider;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    // End of variables declaration//GEN-END:variables

    /**
     * For each minion, simulates that minion attacking and saves the results by updating the attack table
     */
    private void rollAttack()
    {
        //Clears out all of the previous values in the AttackList and then refills out all of them
        //4 values for each attack in order: hit, damage, description, isCritical
        cleanTable(AttackList);
        String[][] attacksFromOneCreature;
        for (int i = 0; i < list.size(); i++)   //For every creature,
        {
            attacksFromOneCreature = list.get(i).attack();
            for (String[] attacksFromOneCreature1 : attacksFromOneCreature) //For every attack each creature made
            {
                String attackRoll;
                if(attacksFromOneCreature1[Minions.ISCRITICALPLACE].equals("true"))
                    attackRoll="nat 20";        //If the attack resulted in a natural 20, then the attackroll inputed value is "nat 20" instead of the normal roll with its modifier to distinguish the two
                else
                    attackRoll=attacksFromOneCreature1[Minions.ATTACKROLLPLACE];
                String[] info = {"" + (i+1),list.get(i).getName(), attackRoll, attacksFromOneCreature1[Minions.DAMAGEPLACE]};  //Values that get updated into table are: Minion spot, Minion name, attack roll, damage
                if (!attackNotes.contains(attacksFromOneCreature1[Minions.DESCRIPTIONPLACE])) {
                    attackNotes.add(attacksFromOneCreature1[Minions.DESCRIPTIONPLACE]);
                    numRepeatingAttackNotes.add(1);
                } else {
                    int index = attackNotes.indexOf(attacksFromOneCreature1[Minions.DESCRIPTIONPLACE]);
                    numRepeatingAttackNotes.add(index, numRepeatingAttackNotes.remove(index)+1);
                }
                updateAttackTableRow(info, Boolean.parseBoolean(attacksFromOneCreature1[Minions.ISCRITICALPLACE]));
            }
        }
    }
    /**
     * Deals damage to the given minion
     * @param damageAmount
     * @param row
     * @param column 
     */
    private void dealDamage(int damageAmount, int row, int column)
    {
        System.out.println("    About to Decrease Health");
        list.get(row).decreaseHealth(damageAmount);
        System.out.println("    Health Decreased");
        if(!list.get(row).shouldRemove())
            MinionList.getModel().setValueAt("" + list.get(row).getHp(), row, column);
        else
        {
            JOptionPane.showMessageDialog(this, "" + list.get(row).getName() + " Has Died!");
            list.remove(row);
            deleteRow(row, MinionList, true);
        }
        System.out.println("    Exiting dealDamage method");
    }
    /**
     * Reads the different rows from a CSV spreadsheet and calls other methods to import the Minion
     * @param theFile 
     */
    private void importDataCSV(File theFile)
    {
        System.out.println("    Into ImportData method");
        Scanner hello;
        try{
            hello = new Scanner(theFile);
            System.out.println("    Able to successfully set a scanner to the file to start reading it");
            System.out.println("    " + theFile);
        } catch (FileNotFoundException e)
        {
            //Logger.getLogger(MainWindow.class.getName()).log(level.SEVERR, null, exec);
            //e.printStackTrace();
            System.out.println("ERROR: " + e.toString());
            return;
        }
        
        String[] me;
        int spot = 0;
        //for every line in the file, collect data and place it where it is needed
        while (hello.hasNextLine())
        {
            try{
                spot++;
                me = hello.nextLine().split(",");
                System.out.println("        At the place in the spreadsheet " + spot + " has the name " + me[0] + " and the length of information is " + me.length);
                //read in each value on the line and create a row
                parseImportedData(me);
            }catch(ClassNotFoundException|InstantiationException|IllegalAccessException e){JOptionPane.showMessageDialog(this, e);e.printStackTrace(); break;}
        }
        System.out.println("    Finished reading all lines in the File");
        
        try{System.out.println(hello.nextLine());}catch(Exception e){System.out.println("There is indeed no other after right now.");}
    }
    /**
     * Exports the Minion information into a CSV spreadsheet. NOT COMPLETE.
     */
    private void exportDataCSV()
    {
        //Have data in program override the spreadsheet. DOES NOT save the health of creatures
        JFileChooser jfc = new JFileChooser();
        if (jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
        {
            try {
                importedFile = jfc.getSelectedFile();
                FileOutputStream fos = new FileOutputStream(importedFile);
                try (ObjectOutputStream oos = new ObjectOutputStream(fos))
                {
                   //CHANGE SO CAN WRITE BACK INTO EXCEL SPREADSHEET######################################################################
                }
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, ex);
                //Logger.getLogger(FTCLeagueSeeder.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    /**
     * Adds in the information about a Minion given through stuff into the Minion Table.
     * @param stuff 
     */
    private void updateMinionTableRow(String[] stuff)
    {
        System.out.println("            updating the Minon Table");
        int i;
        //Adds in info from array and adds it to Minion Table
        for (i = 0; i < MinionList.getModel().getRowCount(); i++)
        {
            if(MinionList.getModel().getValueAt(i, 0).equals(""))
            {
               break; 
            }
        }
        if(i < MinionList.getModel().getRowCount())
        {
            System.out.println("            Existing row");
            MinionList.getModel().setValueAt(i+1 , i, 0);
            for (int a = 0; a < MinionList.getModel().getColumnCount()-1; a++)
            {
                MinionList.getModel().setValueAt(stuff[a], i, a+1);
            }
        }
        else
        {
            System.out.println("            New row");
            DefaultTableModel model = (DefaultTableModel) MinionList.getModel();
            model.addRow(new Object[]{i+1,stuff[0],stuff[1],stuff[2],stuff[3]});
        }
    }
    
    /**
     * This Method goes and adds the values in stuff and puts it into the Attack Table, putting it in the next open one or creates another row and adds the values to that row
     * @param stuff 
     * @param isCritical 
     */
    private void updateAttackTableRow(String[] stuff, boolean isCritical)
    {
        int i;
        //Adds in info from array and adds it to Minion Table
        for (i = 0; i < AttackList.getModel().getRowCount(); i++)   //looking for an open portion of a table
        {
            System.out.println("    The Spot currently being tested to be open in updateAttackTableRow is " + i);
            if(AttackList.getModel().getValueAt(i, 0).equals(""))
            {
               break; 
            }
        }
        System.out.println("The next open row to add the attack is " + i);
        if(i < AttackList.getModel().getRowCount()) //if there is an empty row in the table, adds the attack to that
        {
            AttackList.getModel().setValueAt("", i, AttackList.getModel().getColumnCount()-1);
            for (int a = 0; a < AttackList.getModel().getColumnCount()-1; a++)  //-1 for the didHit row
            {
                AttackList.getModel().setValueAt(stuff[a], i, a);
            }
        }
        else    //if there is not an empty row, makes a new row
        {
            DefaultTableModel model = (DefaultTableModel) AttackList.getModel();
            model.addRow(new Object[]{i,stuff[0],stuff[1],stuff[2],""});
        }
    }
    /**
     * Clears resets all of the values to empty Strings in the given Table
     * @param Table_jTable 
     */
    private void cleanTable(JTable Table_jTable)
    {
        int rows = Table_jTable.getModel().getRowCount();   //clears the table so there are no leftover broken stuff
        int colums = Table_jTable.getModel().getColumnCount();
        for (int c = 0; c < colums; c++)
        {
            for (int r = 0; r < rows; r++)
            {
                Table_jTable.getModel().setValueAt("" , r, c);
            }
        }
    }
    /**
     * Takes the name of a Class of Minion and returns a new instance of it.
     * @param className The String of the name of the Minion
     * @return A new instance of the requested Minion
     * @throws ClassNotFoundException
     * @throws InstantiationException
     * @throws IllegalAccessException 
     */
    private Minions findMinion( String className ) throws ClassNotFoundException,InstantiationException,IllegalAccessException
    {
        if(dynamicallyFindClass)    //Views the boolean to decide if it should try and Dynamically find a class or not
        {
            Class clazz = Class.forName("dndminions." + className);
            Minions mini = (Minions) clazz.newInstance();
            return mini;
        }
        else
        {
            Minions[] classes = new Minions[]{new Zombi(),new Skele(),new BrownBear(), new Lion(), new GiantBoar(), new FireElemental(), new Ghast(), new Ghoul(), new GiantGoat(), new Goat(), new Mastiff(), new Owl(), new Rat()};
            for (Minions classe : classes)
            {
                if (classe.getName().equals(className))
                {
                    return classe;
                }
            }
            throw new ClassNotFoundException();
        }
    }
    /**
     * Clears out all of the tables and ArrayLists
     */
    private void clearNonMonster()
    {
        clearDamageDealtMonsters();
        cleanTable(MinionList);
        cleanTable(AttackList);
        list.clear();
        attackNotes.clear();
        numRepeatingAttackNotes.clear();
    }
    /**
     * Clears all of the tables and lists in the program
     */
    private void clearAll()
    {
        cleanTable(MonsterList);
        cleanTable(MinionList);
        cleanTable(AttackList);
        list.clear();
        attackNotes.clear();
        numRepeatingAttackNotes.clear();
    }
    /**
     * Updates the variables for the current Sliders wizard Level and Proficiency bonus
     */
    private void updateLvAndProficiency()
    {
        wizlv=WizlvSlider.getValue();
        proficiency=ProficiencySlider.getValue();
    }
    /**
     * This method takes a row from a spreadsheet (which should equate to a Minion) and load it into the program
     * @param line A row of the spreadsheet, in order of [name]
     * @throws ClassNotFoundException
     * @throws InstantiationException
     * @throws IllegalAccessException 
     */
    private void parseImportedData(String[] line) throws ClassNotFoundException, InstantiationException, IllegalAccessException
    {
        String putIn[];
        //NOW NEEDS TO BE ABLE TO FIND THAT 2ND PART OF SPREADSHEET, THE NAME, REFERENCES A CLASS AND THEN USE THAT TO GRAB ITS HP AND AC AND DEFAULT 0 FOR ATTACKING###########ClassNotFoundException
        Minions mini = findMinion(line[0]);
        System.out.println("        Did the general reference thing so as to extract the class name from string");
        mini.setUp(wizlv, proficiency, 0);
        System.out.println("        Set up the object to be completely set up");
        list.add(mini);
        putIn = new String[]{mini.getName(),"" + mini.getHp(), "" + mini.getAc(), "1" };
        System.out.println("        put the info into an array");
        updateMinionTableRow(putIn);
    }
    /**
     * Returns if the attack hit or not based upon the value passed in to it. 
     * @param attackRollManualConfirmation String that should contain some form or yes or y if the attack was successful
     * @return If the attack Landed or not
     */
    private boolean attackLanded(String attackRollManualConfirmation)
    {
        return attackRollManualConfirmation.equals("Yes") || attackRollManualConfirmation.equals("Y") || attackRollManualConfirmation.equals("yes") || attackRollManualConfirmation.equals("y");
    }
    /**
     * Clears out all of the values for the damage dealt to monsters in the previous round.
     */
    private void clearDamageDealtMonsters()
    {
        for (int i = 0; i < MonsterList.getModel().getRowCount(); i++)
        {
            MonsterList.getModel().setValueAt("", i, attackListDamageColumn);
        }
    }
    /**
     * Clears all of the remains of a single attack roll, including all of AttackList and summed damage in MonsterList
     */
    private void clearAttackRound()
    {
        clearDamageDealtMonsters();
        cleanTable(AttackList);
        attackNotes.clear();
        numRepeatingAttackNotes.clear();
    }
    /**
     * Deletes a row from the given table
     * @param row The row that is to be deleted
     * @param table The table that a row is to be deleted from
     * @param modifySpotVariables If the function should move around the spot variables in the table. WARNING, NOT COMPATIBLE WITH ATTACKLIST YET
     */
    private void deleteRow(int row, JTable table, boolean modifySpotVariables)
    {
        System.out.println("            Deleting Row");
        DefaultTableModel model = (DefaultTableModel) table.getModel();
        model.removeRow(row);       //Removes a row in the table
        System.out.println("            Deleted Row");
        if(modifySpotVariables)
        {
            try{
            for(int i = row; i < table.getModel().getRowCount(); i++)   //For every row in the table
            {
                System.out.println("                Modifying now row " + i);
                System.out.println("                Current read value is: " + table.getModel().getValueAt(i,spotColumn));
                try{
                    table.getModel().setValueAt("" + (Integer.parseInt((String)table.getModel().getValueAt(i,spotColumn)) - 1), i, spotColumn);  //Takes the value at spotColumn and decreases it by 1
                }catch(ClassCastException e){table.getModel().setValueAt((Integer)table.getModel().getValueAt(i,spotColumn) - 1, i, spotColumn);}   //If the value is stored in the table not as a String it deals with as an int
            }
            }catch(NumberFormatException a){}   //If the spot returns as a "", then it will throw a NumberFormatException, which will be caught by the try-catch outside of the for loop.
        }
    }
    private String convertMinionAttackDescription(String str)
    {
        String converted="";
        System.out.println("    The String about to be converted by MultiAttack is: "+str);
        //This will break up the String based upon attacks in one combination and string them back together again in a way so as to be printed
        String[] convertMultiAttack = str.split(":");
        converted=convertMultiAttack[0];
        for(int i = 1; i < convertMultiAttack.length; i++)
        {
            converted+=" AND "+convertMultiAttack[i];
        }
        
        System.out.println("    The String about to be converted by MultiCombos is: "+converted);
        //This will break up the String based upon how many different combos there are in the String
        String[] convertMultiCombos=converted.split("\n");
        converted=convertMultiCombos[0];
        System.out.println("    The length of the now Array is: " + convertMultiCombos.length);
        for(int i = 1; i < convertMultiCombos.length;i++)
        {
            System.out.println("        This Section of Multicombos is: " + convertMultiCombos[i]);
            converted+="\nOR\n" + convertMultiCombos[i];
        }
        
        return converted;
    }
    private void changeShownRow()
    {
        try{
        if(MinionList.getSelectedRow()!=highlitedRow)
        {
            int spot = MinionList.getSelectedRow();
            //try{
            //    int stuff = Integer.parseInt((String)MinionList.getModel().getValueAt(MinionList.getSelectedRow(), minionListSpot));
            //}catch(ClassCastException e){int stuff = (Integer)MinionList.getModel().getValueAt(MinionList.getSelectedRow(), minionListSpot);}
            if(MinionList.getModel().getValueAt(spot, minionListSpot).equals("") || MinionList.getModel().getValueAt(spot, minionListSpot) == null)
                return;
            
            String setTextAs = convertMinionAttackDescription( list.get(spot).getDescriptions() );
            System.out.println(setTextAs);
            MinionDescriptionField.setText(setTextAs);
            highlitedRow=spot;
        }
        }catch(Exception e){e.printStackTrace();}
    }

}